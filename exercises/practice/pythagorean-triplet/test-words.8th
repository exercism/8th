needs console/loaded

-1 var, test-count

: tests \ n -- 
    test-count ! 
;

: decr-test-count \ --
    test-count @ n:1- test-count !
;

: isword?  \ x -- x f
   dup  >kind  ns:w   n:= 
;

: test_eq \ s x w -- | s w x --
   decr-test-count
   isword? !if swap then
   w:exec
   n:= if
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;

: test_eqs \ s x w -- | s w x -- 
   decr-test-count
   isword? !if swap then
   w:exec
   s:= if
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;

: test_true \ s w --
   decr-test-count
   w:exec
   if
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;

: test_false \ s w --
   decr-test-count
   w:exec
   !if
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;

: test_null \ s w --
   decr-test-count
   w:exec
   null? if
    drop con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    drop con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;

\ compare arrays by testing elements with string equality
: test_eqa \ s x w -- | s w x -- 
   decr-test-count
   isword? !if swap then
   w:exec
   ' s:= a:= nip nip if
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;


: test_map_eq \ m m -- 
   decr-test-count
   isword? !if swap then
   w:exec
   ' n:= m:= if
    2drop
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    2drop
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;

: test_map_neq \ m m -- 
   decr-test-count
   isword? !if swap then
   w:exec
   ' n:= m:= !if
    2drop
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
   else
    2drop
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
   then 
;

\ Compare a1 to a2. Individual elements are compared with w (e.g., n:cmp).
\ The result n is:
\ - The first non-zero result of ( a1[i] a2[i] w ), or
\ - n:cmp of the lengths of a1 and a2
\ Note: This may be used in some test files. For example, to compare results
\ that are not required to be in a certain order.
: a:cmp SED: a1 a2 w -- n
  >r
  over a:len nip over a:len nip n:cmp
  true mark -rot \ Stack: length-cmp a1 a2
  ( r@ w:exec nip dup if break else drop then ) a:2each
  rdrop \ Done with comparison word
  2drop \ Done with a1 and a2
  mark?
  !if \ Got a non-zero result from a compare
    nip
  then
;

\ Test that array a is equal to the result of word w. Compare arrays by
\ testing elements with array equality. The SED of w is -- a1, where a1
\ is an array of arrays. The elements of each sub-array must be numbers.
: test_eqa2 SED: s a w --
  decr-test-count
  isword? !if swap then
  w:exec
  ( ' n:= a:= nip nip ) a:= nip nip
  if
    con:green con:onBlack . space " ... OK" . con:white con:onBlack cr
  else
    con:red con:onBlack . space " ... FAIL" . con:white con:onBlack cr
  then 
;

( test-count @ 0 n:= 
  !if 
  con:red con:onBlack
  "... FAIL - not all tests completed" . 
  con:white con:onBlack 
  cr 
  then ) onexit
